//! # A library that authenticates Azure JWT tokens.
//!
//! This library will fetch public keys from Microsoft and validate the authenticity of the Tokens and verify that they
//! are issued by Azure and are not tampered with.
//!
//! It will also check that this token is issued to the right audience matching the `aud` property of the token with
//! the client_id you got when you registered your app in Azure. If either of these fail, the token is invalid.
//! 
//! # Security
//! You will need a private app_id created by Azure for your application to be able to veriify that
//! the token is created for your application (and not anyone with a valid Azure token can log in) 
//! and you will need to authenticate that the user has the right access to your system.
//! 
//! For more information, see this artice: https://docs.microsoft.com/en-us/azure/active-directory/develop/id-tokens
use chrono::{Duration, Local, NaiveDateTime};
use crypto;
use jwt::{self, Claims, Header, Token};
use reqwest::{self, Response};
use serde::Deserialize;
use std::{error::Error, fmt};

const AZ_OPENID_URL: &str =
    "https://login.microsoftonline.com/common/.well-known/openid-configuration";

/// AzureAuth is the what you'll use to validate your token. I'll briefly explain here what defaults are set and which
/// you can change:
///
/// - Public key expiration: dafault set to 24h, use `set_expiration` to set a different expiration in hours.
/// - Hashing algorithm: Sha256, you can't change this setting. Submit an issue in the github repo if this is important to you
/// - Retry on no match. If no matching key is found and our keys are older than an hour, we refresh the keys and try once more.
///   Limited to once in an hour. You can disable this by calling `set_no_retry()`.
///
/// There are mainly two conditions a well formed token will need to meet to be validated:
/// 1. The token was generated by Azure AD and its contents have not been altered
/// 2. The token is intended to be used with you application
///
/// If the token is invalid it will return an Error instead of a boolean. The main reason for this is easier logging of what
/// type of test it failed.
///
/// # Errors:
/// - If one of Microsofts enpoints for public keys are down
/// - If the token can't be parsed as a valid Azure token
/// - If the tokens fails it's authenticity test
/// - If the token is invalid
#[derive(Debug)]
struct AzureAuth {
    app_key: String,
    jwks_uri: String,
    public_keys: Option<Vec<KeyPairs>>,
    last_refresh: Option<NaiveDateTime>,
    exp_hours: i64,
    retry_counter: u32,
    retry_option: bool,
}

impl AzureAuth {
    pub fn new(app_key: impl Into<String>) -> Result<Self, AuthErr> {
        Ok(AzureAuth {
            app_key: app_key.into(),
            jwks_uri: AzureAuth::get_jwks_uri()?,
            public_keys: None,
            last_refresh: None,
            exp_hours: 24,
            retry_counter: 0,
            retry_option: true,
        })
    }

    fn validate_token(&mut self, token: &str) -> Result<Token<Header, Claims>, AuthErr> {
        let decoded = self.validate_token_authenticity(token)?;
        let decoded = self.validate_aud(decoded)?;

        Ok(decoded)
    }

    fn validate_token_authenticity(&mut self, token: &str) -> Result<Token<Header, Claims>, AuthErr> {
        if !self.is_keys_valid() {
            self.refresh_pub_keys()?;
        }

        let decoded: Token<Header, Claims> =
            Token::parse(token).map_err(|_| AuthErr::ParseError)?;

        let key = match &self.public_keys {
            None => {
                return Err(AuthErr::Other(
                    "Internal err. No public keys found.".to_string(),
                ))
            }
            Some(keys) => match &decoded.header.kid {
                None => return Err(AuthErr::Other("No `kid` in token.".to_string())),
                Some(kid) => keys.iter().find(|k| k.x5t == *kid),
            },
        };

        let auth_key = match key {
            None => {
                // the first time this happens let's go and refresh the keys and try once more.
                // It could be that our keys are out of date. Limit to once in an hour.
                if self.should_retry() {
                    self.refresh_pub_keys()?;
                    self.retry_counter += 1;
                    self.validate_token(token)?;
                    unreachable!()
                } else {
                    self.retry_counter = 0;
                    return Err(AuthErr::Other(
                        "Invalid token. Could not verify authenticity.".to_string(),
                    ));
                }
            }
            Some(key) => {
                self.retry_counter = 0;
                key
            }
        };

        let valid = decoded.verify(auth_key.x5c[0].as_bytes(), crypto::sha2::Sha256::new());

        if valid {
            Ok(decoded)
        } else {
            Err(AuthErr::InvalidToken)
        }
    }

    fn validate_aud(
        &mut self,
        token: Token<Header, Claims>,
    ) -> Result<Token<Header, Claims>, AuthErr> {

        println!("AUD: {:?}", token.claims.reg.aud);
        match &token.claims.reg.aud {
            Some(aud) => {
                if *aud == self.app_key {
                    Ok(token)
                } else {
                    Err(AuthErr::InvalidToken)
                }
            },
            None => Err(AuthErr::InvalidToken)
        }
    }

    fn should_retry(&mut self) -> bool {
        match &self.last_refresh {
            Some(lr) => {
                self.retry_counter == 0 && Local::now().naive_local() - *lr > Duration::hours(1)
            }
            None => false,
        }
    }

    /// Sets the expiration of the cached public keys in hours. Pr. 04.2019 Microsoft rotates these every 24h.
    pub fn set_expiration(&mut self, hours: i64) {
        self.exp_hours = hours;
    }

    pub fn set_no_retry(&mut self) {
        self.retry_option = false;
    }

    fn is_keys_valid(&self) -> bool {
        match self.last_refresh {
            None => false,
            Some(dt) => Local::now().naive_local() - dt <= Duration::hours(self.exp_hours),
        }
    }

    fn refresh_pub_keys(&mut self) -> Result<(), AuthErr> {
        let mut resp: Response =
            reqwest::get(&self.jwks_uri).map_err(|e| AuthErr::ConnectionError(e.to_string()))?;
        let resp: Keys = resp.json().map_err(|e| AuthErr::Other(e.to_string()))?;
        self.public_keys = Some(resp.keys);
        Ok(())
    }

    fn refresh_rwks_uri(&mut self) -> Result<(), AuthErr> {
        self.jwks_uri = AzureAuth::get_jwks_uri()?;
        Ok(())
    }

    fn get_jwks_uri() -> Result<String, AuthErr> {
        let mut resp: Response =
            reqwest::get(AZ_OPENID_URL).map_err(|e| AuthErr::ConnectionError(e.to_string()))?;
        let resp: OpenIdResponse = resp.json().map_err(|e| AuthErr::Other(e.to_string()))?;

        Ok(resp.jwks_uri)
    }
}

#[derive(Debug, Deserialize)]
struct Keys {
    keys: Vec<KeyPairs>,
}

#[derive(Debug, Deserialize)]
struct KeyPairs {
    x5t: String,
    x5c: Vec<String>,
}

#[derive(Deserialize)]
struct OpenIdResponse {
    jwks_uri: String,
}

#[derive(Debug)]
pub enum AuthErr {
    InvalidToken,
    ConnectionError(String),
    Other(String),
    ParseError,
}

impl Error for AuthErr {}

impl fmt::Display for AuthErr {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        use AuthErr::*;

        match self {
            InvalidToken => write!(f, "Invalid token."),
            ConnectionError(inner) => write!(f, "Could not connect to Microsoft. Error: {}", inner),
            Other(msg) => write!(f, "An error occurred: {}", msg),
            ParseError => write!(f, "Could not parse token."),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // see: https://jwt.io/ and go to "Debugger" section to create a test token.
    static TEST_TOKEN: &str = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImtleTEifQ.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyLCJhdWQiOiJhcHBfc2VjcmV0In0.uyhh9ze3DkqVlEpOyeQin-p4MhrYU4gpdYpY4OOMfyY";
    #[test]
    fn decode_token() {
        let key = KeyPairs {
            x5t: "key1".to_string(),
            x5c: vec!["azure_auth_test".to_string()],
        };

        let mut az_auth = AzureAuth::new("app_secret").unwrap();
        az_auth.public_keys = Some(vec![key]);
        az_auth.last_refresh = Some(Local::now().naive_local());

        az_auth.validate_token(TEST_TOKEN).unwrap();
    }

    // #[test]
    // TODO: Refactor to make testing easier
    fn decode_token_retry() {
        let key = KeyPairs {
            x5t: "Xey1".to_string(),
            x5c: vec!["azure_auth_test".to_string()],
        };

        let mut az_auth = AzureAuth::new("app_secret").unwrap();
        az_auth.public_keys = Some(vec![key]);
        az_auth.last_refresh = Some(Local::now().naive_local() - Duration::hours(2));

        az_auth.validate_token(TEST_TOKEN).unwrap();
    }

    #[test]
    fn refresh_rwks_uri() {
        let az_auth = AzureAuth::new("app_secret").unwrap();
    }

    #[test]
    fn azure_ad_get_public_keys() {
        let mut az_auth = AzureAuth::new("app_secret").unwrap();
        az_auth.refresh_pub_keys().unwrap();
    }

    #[test]
    fn is_not_valid_more_than_24h() {
        let mut az_auth = AzureAuth::new("app_secret").unwrap();
        az_auth.last_refresh = Some(Local::now().naive_local() - Duration::hours(25));

        assert!(!az_auth.is_keys_valid());
    }

}
